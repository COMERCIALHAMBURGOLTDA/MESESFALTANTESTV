<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Vencimientos Próximos</title>
  <!-- Recarga completa del HTML cada 300 segundos (5 minutos) -->
  <meta http-equiv="refresh" content="300">
  <style>
    /* Forzar impresión en horizontal */
    @page {
      size: landscape;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
      font-weight: bold; /* Todo el texto en negrita */
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 1.8rem;
      color: #005a9e;
    }
    /* Contenedor que permite scroll horizontal cuando la pantalla sea muy estrecha */
    #tablaVencimientos {
      width: 100%;
      overflow-x: auto;
      margin-bottom: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 600px; /* Asegura cierta anchura mínima */
      background-color: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      font-size: 0.95rem;
      word-break: break-word;
      border-bottom: 1px solid #e0e0e0;
    }
    /* Alinear UBICACIÓN (columna 1) y DESCRIPCION (columna 3) a la izquierda */
    td:nth-child(1),
    td:nth-child(3) {
      text-align: left;
      padding-left: 12px;
    }
    tr:nth-child(even) td {
      background-color: #f9f9f9;
    }
    tr:hover td {
      background-color: #d9edf7;
      cursor: default;
    }
    tr.total-row td {
      background-color: #cccccc;
      font-weight: bold;
    }
    /* Animaciones para parpadeo con colores más fuertes y duración 2.5s */
    @keyframes parpadeo-rojo {
      0%   { background-color: rgba(255, 0, 0, 0.7); }
      50%  { background-color: transparent; }
      100% { background-color: rgba(255, 0, 0, 0.7); }
    }
    .blink-red td {
      animation: parpadeo-rojo 2.5s infinite;
    }
    @keyframes parpadeo-amarillo {
      0%   { background-color: rgba(255, 255, 0, 0.7); }
      50%  { background-color: transparent; }
      100% { background-color: rgba(255, 255, 0, 0.7); }
    }
    .blink-yellow td {
      animation: parpadeo-amarillo 2.5s infinite;
    }
    /* Animación para parpadeo morado (Productos vencidos) en tono más fuerte y duración 2.5s */
    @keyframes parpadeo-morado {
      0%   { background-color: rgba(128, 0, 128, 0.7); }
      50%  { background-color: transparent; }
      100% { background-color: rgba(128, 0, 128, 0.7); }
    }
    .blink-purple td {
      animation: parpadeo-morado 2.5s infinite;
    }
    /* Ajustes para pantallas muy pequeñas */
    @media (max-width: 600px) {
      th, td {
        padding: 8px 6px;
        font-size: 0.85rem;
      }
      table {
        min-width: unset;
      }
    }
  </style>
</head>
<body>
  <h1>Vencimientos Próximos (menos de 30 días o vencidos)</h1>

  <!-- Contenedor responsivo -->
  <div id="tablaVencimientos">
    <div id="spinner">Cargando datos…</div>
  </div>

  <script>
    // 1) Intentar adquirir wake lock para pantalla (Screen Wake Lock API)
    let wakeLock = null;
    async function solicitarWakeLock() {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock adquirido');
        document.addEventListener('visibilitychange', async () => {
          if (wakeLock !== null && document.visibilityState === 'visible') {
            wakeLock = await navigator.wakeLock.request('screen');
          }
        });
      } catch (err) {
        console.warn('No se pudo adquirir Wake Lock:', err);
      }
    }

    /**
     * PARSEAR CADA LÍNEA DE CSV respetando comillas dobles
     * y comas internas.
     */
    function parseCSVLine(line) {
      const result = [];
      let campo = "";
      let dentroDeComillas = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"') {
          // Si estamos dentro de comillas y la siguiente también es comilla, 
          // interpretamos que es una comilla escapada ("")
          if (dentroDeComillas && line[i + 1] === '"') {
            campo += '"';
            i++;
          } else {
            // Alternamos el estado de dentroDeComillas
            dentroDeComillas = !dentroDeComillas;
          }
        } else if (char === "," && !dentroDeComillas) {
          // Coma que separa campos (solo si NO estamos dentro de comillas)
          result.push(campo);
          campo = "";
        } else {
          // Cualquier otro carácter (incluidas comas dentro de comillas)
          campo += char;
        }
      }
      // Agregar el último campo pendiente
      result.push(campo);
      return result;
    }

    // 2) URL del CSV publicado desde Google Sheets
    const CSV_URL_BASE =
      "https://docs.google.com/spreadsheets/d/e/" +
      "2PACX-1vQNpc-4hMLcvSv4pO4Zirf528ePaScC-l6OGPS5nU_4peDVfs3ur6ih5row8HUs6_BKkoIQhvPvDMiv" +
      "/pub?gid=208523845&single=true&output=csv";

    let datosVálidos = [];

    // Función para fetch + parsear CSV correctamente
    function fetchYParsearCSV() {
      document.getElementById("tablaVencimientos").innerHTML =
        '<div id="spinner">Cargando datos…</div>';

      fetch(CSV_URL_BASE)
        .then(response => {
          if (!response.ok) throw new Error("Error al cargar el CSV principal.");
          return response.text();
        })
        .then(csvText => {
          // 1) Partir en filas
          const filas = csvText.trim().split("\n");

          // 2) El encabezado necesita parseCSVLine en lugar de split(",")
          const encabezados = parseCSVLine(filas[0]).map(h => h.trim());

          // 3) Ahora procesar línea a línea con parseCSVLine
          datosVálidos = filas.slice(1)
            .map(linea => {
              const valores = parseCSVLine(linea);
              const obj = {};
              encabezados.forEach((key, i) => {
                obj[key] = valores[i] ? valores[i].trim() : "";
              });
              return obj;
            })
            .map(r => {
              // Convertir “TOTAL $” a número
              r["TOTAL $"] = parseFloat(r["TOTAL $"].replace(/[^0-9.-]+/g, "")) || 0;

              // Parsear “FECHA VENCIMIENTO” a Date, manejando d/m/yy ó d/m/yyyy
              const fechaRaw = r["FECHA VENCIMIENTO"];
              let fechaObj;
              if (fechaRaw.includes("/")) {
                const partes = fechaRaw.split("/").map(p => p.trim());
                let dia = parseInt(partes[0], 10);
                let mes = parseInt(partes[1], 10) - 1; // JS: 0=enero
                let anioRaw = partes[2];
                let anioNum = parseInt(anioRaw, 10);
                if (anioRaw.length <= 2) {
                  anioNum += 2000; // ejemplo: "27" → 2027
                }
                fechaObj = new Date(anioNum, mes, dia);
              } else {
                fechaObj = new Date(fechaRaw);
              }
              r._FECHA = fechaObj;
              return r;
            })
            .filter(r =>
              r["BODEGA"]?.trim() &&
              r["NIVEL"]?.trim() &&
              r["FAMILIA"]?.trim() &&
              !isNaN(r["TOTAL $"]) &&
              r._FECHA instanceof Date &&
              !isNaN(r._FECHA)
            );

          dibujarTablaVencimientos();
        })
        .catch(err => {
          console.error(err);
          document.getElementById("tablaVencimientos").innerHTML =
            "No se pudieron cargar los datos de vencimientos.";
        });
    }

    // Función para filtrar y dibujar la tabla
    function dibujarTablaVencimientos() {
      if (!Array.isArray(datosVálidos) || datosVálidos.length === 0) {
        document.getElementById("tablaVencimientos").innerHTML =
          '<div id="spinner">Sin datos para mostrar.</div>';
        return;
      }

      const hoy = new Date();
      // Mostrar vencidos (diffDias < 0) o próximos 30 días (diffDias ≥ 0 y < 30)
      const itemsProx = datosVálidos
        .filter(r => {
          const diffDias = (r._FECHA - hoy) / (1000 * 60 * 60 * 24);
          return diffDias < 30;
        })
        .sort((a, b) => a._FECHA - b._FECHA);

      let sumMonto = 0;
      let html = `<table>
                    <thead>
                      <tr>
                        <th>UBICACIÓN</th>
                        <th>CÓDIGO VENTA</th>
                        <th>DESCRIPCION</th>
                        <th>FECHA VENCIMIENTO</th>
                        <th>DÍAS FALTANTES</th>
                        <th>UNIDADES</th>
                        <th>BULTOS</th>
                        <th>MONTO</th>
                      </tr>
                    </thead>
                    <tbody>`;

      if (itemsProx.length === 0) {
        html += `<tr><td colspan="8">No hay productos con vencimiento en los próximos 30 días ni vencidos.</td></tr>`;
      } else {
        itemsProx.forEach(r => {
          const d = r._FECHA;
          const diffDias = Math.floor((d - hoy) / (1000 * 60 * 60 * 24));
          const ubic = `${r["BODEGA"]}-${r["NIVEL"]}-${r["PASILLO"]}-${r["RACK"]}`;
          const montoTrunc = Math.trunc(r["TOTAL $"]);
          const unidadesMostrar = r["UNIDADES"] ? parseInt(r["UNIDADES"], 10) : 0;
          const nivelUpper = r["NIVEL"].toUpperCase();
          const fuerzaCeroBultos = nivelUpper.includes("PICKEO") || nivelUpper.includes("CHICLES");
          const bultosMostrar = fuerzaCeroBultos
            ? 0
            : (r["BULTOS"] ? parseInt(r["BULTOS"], 10) : 0);
          sumMonto += montoTrunc;

          const dd = String(d.getDate()).padStart(2, "0");
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const yyyy = d.getFullYear();
          const fechaFmt = `${dd}/${mm}/${yyyy}`;

          let displayDias;
          let claseFila = "";

          if (diffDias < 0) {
            displayDias = "PRODUCTO VENCIDO";
            claseFila = "blink-purple";
          } else {
            displayDias = diffDias;
            if (diffDias <= 4) {
              claseFila = "blink-red";
            } else if (diffDias >= 5 && diffDias <= 10) {
              claseFila = "blink-yellow";
            }
          }

          html += `<tr class="${claseFila}">
                     <td>${ubic}</td>
                     <td>${r["CODIGO VENTA"] || ""}</td>
                     <td>${r["DESCRIPCION"] || ""}</td>
                     <td>${fechaFmt}</td>
                     <td>${displayDias}</td>
                     <td>${unidadesMostrar}</td>
                     <td>${bultosMostrar}</td>
                     <td>${montoTrunc.toLocaleString("es-CL", { minimumFractionDigits: 0 })}</td>
                   </tr>`;
        });

        html += `<tr class="total-row">
                   <td colspan="7"></td>
                   <td><strong>${sumMonto.toLocaleString("es-CL", { minimumFractionDigits: 0 })}</strong></td>
                 </tr>`;
      }

      html += `</tbody></table>`;
      document.getElementById("tablaVencimientos").innerHTML = html;
    }

    // Al cargar la página:
    // • intentamos adquirir wake lock
    // • hacemos fetch+parse inicial
    // • redraw cada 2 min (sin volver a fetch)
    window.addEventListener("DOMContentLoaded", () => {
      solicitarWakeLock();
      fetchYParsearCSV();
      setInterval(dibujarTablaVencimientos, 120000);
      // El fetch completo se realizará al inicio y tras el meta-refresh cada 5 min
    });
  </script>
</body>
</html>
