<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Vencimientos Próximos</title>
  <!-- Recarga completa del HTML cada 300 s (5 minutos) -->
  <meta http-equiv="refresh" content="300">
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.8rem;
      color: #005a9e;
    }
    /* Contenedor que permite scroll horizontal en pantallas estrechas */
    #tablaVencimientos {
      width: 100%;
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 600px; /* Anchura mínima para evitar que las columnas se compriman demasiado */
      background-color: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      font-size: 0.95rem;
      word-break: break-word;
      border-bottom: 1px solid #e0e0e0;
    }
    th {
      background-color: #007acc;
      color: #fff;
      font-weight: 600;
    }
    /* Alinear UBICACIÓN (columna 1) y DESCRIPCIÓN (columna 3) a la izquierda */
    td:nth-child(1),
    td:nth-child(3) {
      text-align: left;
      padding-left: 12px;
    }
    tr:nth-child(even) td {
      background-color: #f9f9f9;
    }
    tr:hover td {
      background-color: #d9edf7;
      cursor: default;
    }
    tr.total-row td {
      background-color: #cccccc;
      font-weight: bold;
    }
    /* Parpadeo rojo/amarillo según días faltantes */
    @keyframes parpadeo-rojo {
      0%   { background-color: rgba(255, 0, 0, 0.2); }
      50%  { background-color: transparent; }
      100% { background-color: rgba(255, 0, 0, 0.2); }
    }
    .blink-red td {
      animation: parpadeo-rojo 1s infinite;
    }
    @keyframes parpadeo-amarillo {
      0%   { background-color: rgba(255, 255, 0, 0.3); }
      50%  { background-color: transparent; }
      100% { background-color: rgba(255, 255, 0, 0.3); }
    }
    .blink-yellow td {
      animation: parpadeo-amarillo 1s infinite;
    }
    /* Ajustes para pantallas súper pequeñas */
    @media (max-width: 600px) {
      th, td {
        padding: 8px 6px;
        font-size: 0.85rem;
      }
      table {
        min-width: unset;
      }
    }
    /* Indicador de “Cargando…” */
    #spinner {
      text-align: center;
      margin-top: 40px;
      font-size: 1rem;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>Vencimientos Próximos (menos de 30 días)</h1>
  <!-- Contenedor donde irá la tabla -->
  <div id="tablaVencimientos">
    <div id="spinner">Cargando datos…</div>
  </div>

  <script>
    // URL del CSV publicado desde Google Sheets
    const CSV_URL_BASE =
      "https://docs.google.com/spreadsheets/d/e/" +
      "2PACX-1vQNpc-4hMLcvSv4pO4Zirf528ePaScC-l6OGPS5nU_4peDVfs3ur6ih5row8HUs6_BKkoIQhvPvDMiv" +
      "/pub?gid=208523845&single=true&output=csv";

    // Variable global para almacenar los datos parseados (una sola vez por recarga completa)
    let datosVálidos = [];

    // ===================================================
    // 1) Función que se encarga de hacer fetch + parseo
    //    Esta sólo se llama 1 vez al inicio (o cada 5 minutos,
    //    cuando el meta-refresh recarga todo el HTML).
    // ===================================================
    function fetchYParsearCSV() {
      // Mostrar spinner mientras carga
      document.getElementById("tablaVencimientos").innerHTML =
        '<div id="spinner">Cargando datos…</div>';

      fetch(CSV_URL_BASE)
        .then(response => {
          if (!response.ok) {
            throw new Error("Error al cargar el CSV principal.");
          }
          return response.text();
        })
        .then(csvText => {
          // Separar líneas y encabezados
          const filas = csvText.trim().split("\n");
          const encabezados = filas[0].split(",");

          // Mapear cada línea a un objeto { columna: valor, … }
          datosVálidos = filas.slice(1).map(linea => {
            const valores = linea.split(",");
            const obj = {};
            encabezados.forEach((key, i) => {
              obj[key.trim()] = valores[i] ? valores[i].trim() : "";
            });
            return obj;
          })
          // Convertir “TOTAL $” a número y “FECHA VENCIMIENTO” a Date
          .map(r => {
            r["TOTAL $"] = parseFloat(r["TOTAL $"].replace(/[^0-9.-]+/g, "")) || 0;
            const fechaRaw = r["FECHA VENCIMIENTO"];
            let fechaObj;
            if (fechaRaw.includes("/")) {
              const partes = fechaRaw.split("/");
              fechaObj = new Date(
                parseInt(partes[2], 10),
                parseInt(partes[1], 10) - 1,
                parseInt(partes[0], 10)
              );
            } else {
              fechaObj = new Date(fechaRaw);
            }
            r._FECHA = fechaObj;
            return r;
          })
          // Filtrar sólo registros válidos
          .filter(r =>
            r["BODEGA"]?.trim() &&
            r["NIVEL"]?.trim() &&
            r["FAMILIA"]?.trim() &&
            !isNaN(r["TOTAL $"]) &&
            r._FECHA instanceof Date &&
            !isNaN(r._FECHA)
          );

          // Una vez parseados, dibujamos la tabla por primera vez
          dibujarTablaVencimientos();
        })
        .catch(err => {
          console.error(err);
          document.getElementById("tablaVencimientos").innerText =
            "No se pudieron cargar los datos de vencimientos.";
        });
    }

    // ===================================================
    // 2) Función para filtrar y dibujar la tabla en pantalla.
    //    Esta se llamará cada 2 minutos, sin volver a fetch/parsear.
    // ===================================================
    function dibujarTablaVencimientos() {
      // Si aún no hay datos parseados, mostramos mensaje y salimos.
      if (!Array.isArray(datosVálidos) || datosVálidos.length === 0) {
        document.getElementById("tablaVencimientos").innerHTML =
          '<div id="spinner">Sin datos para mostrar.</div>';
        return;
      }

      const hoy = new Date();
      // Filtrar sólo los items con fecha de vencimiento en < 30 días
      const itemsProx = datosVálidos.filter(r => {
        const diffDias = (r._FECHA - hoy) / (1000 * 60 * 60 * 24);
        return diffDias >= 0 && diffDias < 30;
      })
      // Ordenar de más cercano a más lejano
      .sort((a, b) => (a._FECHA - b._FECHA));

      let sumMonto = 0;
      // Empezamos a construir el HTML de la tabla
      let html = `<table>
                    <thead>
                      <tr>
                        <th>UBICACIÓN</th>
                        <th>CÓDIGO VENTA</th>
                        <th>DESCRIPCIÓN</th>
                        <th>FECHA VENCIMIENTO</th>
                        <th>DÍAS FALTANTES</th>
                        <th>UNIDADES</th>
                        <th>BULTOS</th>
                        <th>MONTO</th>
                      </tr>
                    </thead>
                    <tbody>`;

      if (itemsProx.length === 0) {
        html += `<tr><td colspan="8">No hay productos con vencimiento en los próximos 30 días.</td></tr>`;
      } else {
        // Generar cada fila
        itemsProx.forEach(r => {
          const d = r._FECHA;
          const diffDias = Math.floor((d - hoy) / (1000 * 60 * 60 * 24));
          const ubic = `${r["BODEGA"]}-${r["NIVEL"]}-${r["PASILLO"]}-${r["RACK"]}`;
          const montoTrunc = Math.trunc(r["TOTAL $"]);
          const unidadesMostrar = r["UNIDADES"] ? parseInt(r["UNIDADES"], 10) : 0;
          const nivelUpper = r["NIVEL"].toUpperCase();
          // Si el nivel incluye “PICKEO” o “CHICLES”, bultos = 0
          const fuerzaCeroBultos = nivelUpper.includes("PICKEO") || nivelUpper.includes("CHICLES");
          const bultosMostrar = fuerzaCeroBultos
            ? 0
            : (r["BULTOS"] ? parseInt(r["BULTOS"], 10) : 0);
          sumMonto += montoTrunc;

          const dd = String(d.getDate()).padStart(2, "0");
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const yyyy = d.getFullYear();
          const fechaFmt = `${dd}/${mm}/${yyyy}`;

          // Asignar clase para parpadeo según días
          let claseFila = "";
          if (diffDias <= 4) {
            claseFila = "blink-red";
          } else if (diffDias >= 5 && diffDias <= 10) {
            claseFila = "blink-yellow";
          }

          html += `<tr class="${claseFila}">
                     <td>${ubic}</td>
                     <td>${r["CODIGO VENTA"] || ""}</td>
                     <td>${r["DESCRIPCION"] || ""}</td>
                     <td>${fechaFmt}</td>
                     <td>${diffDias}</td>
                     <td>${unidadesMostrar}</td>
                     <td>${bultosMostrar}</td>
                     <td>${montoTrunc.toLocaleString("es-CL", { minimumFractionDigits: 0 })}</td>
                   </tr>`;
        });

        // Fila de total al final
        html += `<tr class="total-row">
                   <td colspan="7"></td>
                   <td><strong>${sumMonto.toLocaleString("es-CL", { minimumFractionDigits: 0 })}</strong></td>
                 </tr>`;
      }

      html += `</tbody></table>`;
      // Insertar el resultado en el contenedor
      document.getElementById("tablaVencimientos").innerHTML = html;
    }

    // ===================================================
    // 3) Configurar el flujo al cargar la página:
    //    - Primero: fetch+parse (carga inicial)
    //    - Luego, cada 2 minutos: sólo redibujar tabla con datos en memoria
    // ===================================================
    window.addEventListener("DOMContentLoaded", () => {
      fetchYParsearCSV();               // 1ª carga de CSV
      setInterval(dibujarTablaVencimientos, 120000); // Refrescar sólo la tabla cada 2 min
      // (el fetch completo sólo se hará cuando el meta-refresh recargue la página cada 5 minutos)
    });
  </script>
</body>
</html>
